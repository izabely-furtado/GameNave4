{"name":"Gamenave3","tagline":"Trabalho a ser feito para o professor de POO2, como um dos requisitos para nota para o Trabalho 2","body":"### **TRABALHO DA DISCIPLINA PROGRAMAÇÃO ORIENTADA A OBJETOS 2**\r\n\r\n**Projeto: Jogo Nave**\r\n\r\n**1.\tRegistro de Alterações**\r\n\r\n\r\n**Versão** = 3\r\n\r\n**Responsáveis** = Izabely Corrêa e Gislaine Almeida\r\n\r\n**Data** = 22/11/2015\r\n\r\n**Alterações** = \r\n* Modificação do Diagrama Build,\r\n* Diagrama e Explicação do Padrão Flywheigt, \r\n* Implementação do Reflection\r\n* Explicação das mudanças, \r\n* Descrição da Utilização DAO e \r\n* Refatoração\r\n* Foram retiradas as variáveis globais e foi feito o Enum **Metricas**\r\n\r\n### **2.\tIntrodução**\r\n\r\nEste documento apresenta um relatório de projeto e engenharia do sistema de um jogo de naves. Este documento está organizado da seguinte forma: a seção 3 apresenta o padrão Fábrica utilizado, seus respectivos  diagramas, motivações e explicações, a seção 4 apresenta o padrão Builder utilizado, seus respectivos  diagramas, motivações e explicações , a seção 5 demonstra o diagrama de classes e o de composição de estruturas e descreve a utilização MVC, a seção 6 demonstra a diferença evidenciada com a refatoração do código, a seção 7 descreve um passo a passo de como deve rodar o programa.\r\n\r\n### **3.\tPadrão Fábrica**\r\n\r\nAplicada a Objetos nas Fases do Jogo: Naves e Itens\r\n\r\n ![](https://github.com/izabely-furtado/GameNave2/blob/master/diagramas/PadraoFabrica.png?raw=true)\r\n\r\n\r\n**3.1.\tMotivo da Utilização**\r\n\r\n\r\nO padrão em questão foi utilizado para fabricação de objetos que estarão em cada fase, sendo esses itens e/ou naves.\r\n\r\nO Factory Method foi utilizado para esse projeto, pois nessas condições o padrão nos oferece um meio de desligar a implementação de um produto final em si. Por exemplo, caso quisesse desenvolver um novo inimigo, a criação deste estaria facilitada e em nível de chamada, pode-se chamar qualquer nave inimiga, como uma nave ou simplesmente um objeto. \r\n\r\nAlém disso, o padrão fábrica, faz com que não haja repetição de código, dado que caso queira fabricar um novo item, poderia já abstrair este como um objeto e somente implementar as modificações ocasionadas no jogo. Mas isso tudo é feito de forma mais intuitiva, como uma espécie de montagem facilitadora, uma casca que define a criação de elementos presentes em cada classe. Assim, há um local único para ser modificado, assim, um local único para fazer manutenção, dando um código flexível e extensível no futuro.\r\n\r\nPara completar, caso o uma nave específica ou um item precise ser desligado ou deletado, a alteração não irá afetar demais classes, principalmente não irá afetar seu “criador”, pois eles não estarão fortemente ligados. Facilitando, assim, a manutenção do código, pois encapsula esse comportamento de instanciação.\r\n\r\n **3.2.\tExplicação do Diagrama**\r\n\r\n\r\nNo diagrama de classe acima temos a classe **FabricaAtributoAcao** definida como interface (já que Python não possui interface ela é apenas uma classe abstrata com funções abstratas) que define os métodos que deverão ser implementados por sua subclasse, a classe abstrata **FabricaObjeto**.\r\n\r\nAmbas classes, tanto FabricaItem, quanto FabricaNave, que estendem a classe FabricaObjeto serão objetos na tela que possuem o mesmo comportamento de, ou seja, se movem e possuem uma figura que os representa. Estendendo de FabricaObjeto, possuem os atributos e podem utilizar e/ou sobrescrever os métodos existentes no super.\r\n\r\nNo diagrama de classes temos a classe **FabricaObjeto** como abstrata que define atributos que cabem a qualquer nave e objeto no jogo, além dos métodos que definem comportamentos comuns entre as naves e itens e que deverão ser sobrescritos por cada subclasse, que são:\r\n* move()\r\n* criaVelocidade() \r\n\r\n\r\nIsso deve ser feito, pois cada nave possui seu próprio movimento, velocidade e, já que é uma nave também, sua própria resistência, no caso de um item, este deve possuir suas próprias modificações.\r\n\r\n\r\n**3.2.1.\tFabrica Naves**\r\n\r\n\r\n**3.2.1.1.\tInimigas**\r\n\r\n\r\nTodas as naves inimigas devem conter o dado referente sobre a pontuação que o jogador arrecada por derrota-la, sendo que a explosão ficou igual a todas as naves por conveniência, no entanto, só algumas naves inimigas atiram.\r\n\r\nSendo assim, temos a classe **FabricaNaveInimiga** como abstrata estende **FabricaNave** e define atributos que cabem a qualquer nave inimiga, além disso, as classes que a estende, sobrescrevem as funções necessárias para toda nave, já mencionadas.\r\n\r\nAlguns naves inimigas, além de implementarem as funções mencionadas, implementam atributos e métodos que possibilitam atirar.\r\n\r\n\r\n**3.2.1.2.\tJogador**\r\n\r\n\r\nA Nave do Jogador é análoga a qualquer nave, só que esta deve permitir que o jogador possa atirar em seus inimigos. \r\n\r\n\r\n**3.2.2.\tFabrica Itens**\r\n\r\n\r\nCada item faz modificações na nave ou no status do jogador e, como tal, possui seu preço, caso queira ser trocada por uma pontuação e a probabilidade de aparecimento durante uma fase. Além de possuir os atributos e métodos que estão no super estendido, **FabricaObjeto**.\r\n\r\n\r\n### **4.\tPadrão Builder**\r\n\r\n\r\nAplicada a Fabrica de Naves\r\n \r\n![](https://github.com/izabely-furtado/GameNave3/blob/gh-pages/diagramas/PadraoBuild.png?raw=true)\r\n\r\n**4.1.\tMotivo da Utilização**\r\n\r\n\r\nA motivação foi separar a construção de um objeto complexo de sua representação de modo que o mesmo processo de construção possa criar diferentes representações.\r\n\r\nNesse caso deu à separação da fabricação de uma nave, do dano causado a mesma, do som que esta emite e da imagem referente a ela e sua explosão. Seguindo em si, a mesma ideia dos padrões Factory Method e Abstract Factory. No entanto, permitindo separar os passos da construção da nave em pequenos métodos que são:\r\n* BuildDano()\r\n* BuildImagemNave()\r\n* BuildImagemExplosao()\r\n* BuildSom()\r\n\r\n\r\nNo padrão Builder temos também uma interface comum para todos os objetos que constroem outros objetos. Essa interface Builder define todos os passos necessários para construir  cada tipo de nave, sendo essa a de um jogador ou inimiga.\r\n\r\n\r\n**4.2.\tExplicação do Diagrama**\r\n\r\n\r\n**4.2.1.\tNaveProduct**\r\n\r\n\r\nNada mais é do que uma estrutura de dados que armazena as informações de uma nave. A nossa classe Builder vai possui um método para construir cada um dos dados do produto em questão.\r\n\r\n\r\n**4.2.2.\tNaveBuilder**\r\n\r\n\r\nNesta classe temos a nave que será construída, os passos para sua construção e um método que devolve a nave construída. \r\n\r\nEstá classe em questão é abstrata os métodos em si serão implementados por cada classe abstrata que o estender, não existindo assim um “algoritmo” bem definido, o algoritmo será definido em outro lugar nos filhos.  Sendo assim, em cada uma das classes que o estender esses métodos implementar estarão “personalizando” a nave.\r\n\r\n\r\n**4.2.3.\tNaveJogoDirector**\r\n\r\n\r\nA classe chamada de **Director**, utiliza a estrutura do **Builder** para definir o algoritmo de construção do Produto.\r\n\r\nSendo que, dado um Builder, a classe vai executar os métodos de construção, definindo assim o algoritmo de construção de naves, e depois devolve nave. O código cliente vai lidar apenas com o Director, toda a estrutura e algoritmos utilizados para construir a nave fica por debaixo dos panos.\r\n\r\n\r\n### 5.\tPadrão Peso-Mosca\r\n\r\nDiagrama que representa a implementação do padrão peso-mostra aplicada a criação de novas naves inimigas\r\n\r\n![](https://github.com/izabely-furtado/GameNave3/blob/gh-pages/diagramas/PadraoFlyweight.png?raw=true)\r\n\r\n**Motivo da Utilização**\r\n\r\n> \"Esse padrão como usa compartilhamento para suportar eficientemente grandes quantidades de objetos de granularidade fina.\" - [1] GAMMA, Erich et al. Padrões de Projeto: Soluções reutilizáveis de software orientado a objetos.\r\n\r\nEsse padrão foi utilizado para reduzir o espaço de memória e processamento exigido para a construção de cada nova nave inserida no jogo. A utilização foi dado devido a que várias naves semelhantes são inseridas aleatoriamente no jogo.\r\n\r\nPela intenção percebemos que o padrão Flyweight cria uma estrutura de compartilhamento de objetos pequenos. Para o exemplo citado, o padrão será utilizado no compartilhamento de imagens entre as entidades, além de alguns atributos não mutáveis.\r\n\r\n**Exemplos de Código**\r\n\r\n` \r\nclass NaveFlyweightFactory (object):\r\n\r\n     def __init__(self):\r\n\r\n         self._standardBoss = [0, None]\r\n         self._standardFuga = [0, None]\r\n         self._standardGrupo = [0, None]\r\n         self._standardJogador = [0, None]\r\n         self._standardPeao = [0, None]\r\n         self._standardPerdida = [0, None]\r\n         self._standardPersegue = [0, None]\r\n`\r\n\r\nO **_init_** é feito de modo q inicializar a quantidades de naves como 0 e as naves como ainda não existentes, com isso o modo caso ainda não tenha sido setados os valores as naves não ocupam muito espaço e caso contrário, se for a primeira vez a nave é criada normalmente, mas das próximas vezes só é mudada a quantidade, ela não é criada do zero. Assim como mostrado no **get_Standard_Boss** abaixo.\r\n\r\n`\r\n     def get_Standard_Boss(self, quant_nave):\r\n\r\n         e = self._standardBoss\r\n         if e[1] == None:\r\n             e[1] = NaveBossBuilder.__init__(NaveBossBuilder)\r\n             self._standardBoss[0] = quant_nave\r\n             self._standardBoss[1] = e[1]\r\n\r\n         return e \r\n`\r\n\r\n### 6.\tBanco de Dados - ActiveRecord\r\n\r\nDiagrama que representa a implementação para o uso e criação do banco de dados\r\n\r\n**Motivo da Utilização**\r\n\r\n<<<<Insira aqui o motivo>>>>\r\n\r\n**Explicação do Diagrama**\r\n\r\n<<<<Insira aqui a explicação>>>>\r\n\r\n\r\n### 7.\tMVC\r\n\r\n**Diagrama de Composição de Estruturas**\r\n\r\n ![](https://github.com/izabely-furtado/GameNave2/blob/master/diagramas/ComposicaoEstrutural.png?raw=true)\r\n\r\nEsse diagrama destina-se a descrição dos relacionamentos entre os elementos. Utilizado para descrever a colaboração interna de classes, interfaces ou componentes para especificar uma funcionalidade.\r\n\r\nEssa colaboração interna começa a se basear no modelo MVC, que se trata de um padrão de arquitetura de software que separa a representação da informação da interação do usuário com ele. Utilizando-se das ideias centrais por trás do MVC, que são a reusabilidade de código e separação de conceitos.\r\n\r\nO modelo consiste nos dados da aplicação, regras de negócios, lógica e funções, que nesse caso estão na **CamadaDomínioProblema**, que possui as classes que foram indicadas no diagrama de classes.\r\n\r\nUma visão pode ser qualquer saída de representação dos dados, que estão na **CamadaGestaoDados**, como as músicas tocadas no jogo e as imagens que demonstram as naves a as munições, por exemplo.  Assim como podem ser representação de dados que pode se haver uma interação, como botões e janelas, que estão na **CamadaInteraçãoHumana**.\r\n\r\nO controlador faz a mediação da entrada, convertendo-a em comandos para o modelo ou visão, estão nesse caso na CamadaControleInterface.\r\n\r\nAssim, a partir disse a camada de aplicação da nave, chama em uma linha a função da **CamadaControleInterface**  a função que chama o menu inicial.\r\n\r\n### 8.\tRefatoração do Código - Avaliação SONAR\r\n\r\n**Resultados do Sonar**\r\n\r\n\r\n**1. Na primeira versão**\r\n\r\n![](https://github.com/izabely-furtado/GameNave2/blob/master/diagramas/sonar1.png?raw=true)\r\n\r\n**2. Na segunda versão**\r\n\r\n![](https://github.com/izabely-furtado/GameNave2/blob/master/diagramas/sonar2.png?raw=true)\r\n\r\nOs padrões de projeto, como já mencionados acima, ajudaram para que o código fosse melhor avaliado pelo sonar.\r\n\r\n**3. Na segunda versão**\r\n\r\n![](https://github.com/izabely-furtado/GameNave3/blob/gh-pages/diagramas/sonar3.png?raw=true)\r\n\r\nDado o uso do método fábrica, por exemplo, o nível de duplicação do código está em 0.0%. \r\n\r\nE, isso ocorreu mesmo com a criação de diversas novas classes referentes a objetos na tela em geral, tanto itens, quanto naves foram “fabricadas” de modo a fazer com que não houvesse essa duplicação. Dado a percepção do que havia em comum entre as classes.\r\n\r\nO padrão builder, assim como o fábrica funcionou dá mesma forma. Só que evidenciando fatores mutáveis nas naves.\r\n\r\nAlém disso, funções escritas com poucas linhas de forma objetiva e intuitiva, além de ajudar na troca de código dentre o grupo, melhorou a nota referente a funções do sonar.\r\nMas aplicar o padrão fez com que as linhas de código aumentassem e muito de início, no entanto, por exemplo, os padrões fábrica e builder facilitam caso queira se inserir uma nova classe com comportamento diferenciado. Essa facilidade é adquirida de duas formas:\r\n\r\nConsiderando que já há um molde para a criação do novo objeto, não vai haver a “criação da roda” já que muitos quesitos simplesmente serão aproveitados.\r\n\r\nO aproveitamento do código já existente evita a duplicação\r\n\r\nJá nessa terceira versão houve uma motivação para serem feitas algumas modificações necessárias, mas primordialmente não mudou muito na nota dada pelo sonar, dado que o padrão implementado, em si, modifica mais em tempo de execução do na formatação do código em si.\r\n\r\nNa real aumentaram o número de classes, pois passou ser mais orientado a interface e por conta dos diversos padrões implementados.\r\n\r\n### 9.\tTestes Unitários\r\n\r\nOs testes unitários foram aplicados nos seguinte locais:\r\n\r\n* nas funções de negócio relacionadas ao **Controle**, verificando se as naves obedecem aos parâmetros da tela\r\n* nas funções de contrução e criação relacionadas a **FabricaNave** e seus descendentes, primordialmente relacionado aos movimentos das naves\r\n* nas funções do **NaveBuilder** relacionadas e inserção de dano nas naves\r\n* nas habilidades relacionadas primordialmente a **Munição**\r\n* no **Jogador** relacionadas as funções que modificam os atributos do mesmo\r\n\r\n### 10.\tReflection\r\n\r\nVisando fazer com que o programa tenha a capacidade de um programa de observar ou até mesmo modificar a sua estrutura ou comportamento de uma nave em tempo de execução foi usado o **Reflection** relacionando com a construção e um **BuildGeral** para a criação de naves da seguinte forma:\r\n\r\n`\r\nclass BuildGeral(object):\r\n\r\n    @staticmethod\r\n    def criar(name):\r\n        path = 'util.Build.Nave'+ name + 'Builder'\r\n        #'util.Build.NavesGrupoBuilder'\r\n        components = name.split('.')\r\n        mod = __import__(components[0])\r\n\r\n        for comp in components[1:]:\r\n            mod = getattr(mod, comp)\r\n`\r\n\r\n### 10.\tInstalação\r\n\r\nFuturamente o jogo pretende gerar um executável para facilitar a inicialização do jogo para ser usado, mas enquanto essas melhorias não são implementadas algumas configurações devem ser realizadas. \r\n\r\nPara que o jogo nave rode em um computador é necessário fazer a instalação do python versão 3.4, foi utilizado e a biblioteca pygame compatível com a versão do python utilizada. Utilizando uma ide que possa ser configurado o Python para interpretar, o programa pode ser rodado e jogado, ainda não como gostaríamos devido a vários contratempo tecnológicos e de aprendizado, mas em uma versão bem básica. \r\n\r\n**Observação:** Ao tentar rodar no Windows pode ser que não seja possível executar, pois a biblioteca de jogos para esse sistema só abrange até o python 3.2 e o programa utiliza como base outra versão. Por algum motivo que ainda não descobrimos, as imagens não estão sendo possíveis de ser carregadas sem que se passe o caminho das mesmas.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}