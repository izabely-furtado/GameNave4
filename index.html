<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>GameNave4 by izabely-furtado</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>GameNave4</h1>
        <p>Trabalho a ser feito para o professor de POO2, como um dos requisitos para nota para o Último Trabalho</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/izabely-furtado/GameNave4" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/izabely-furtado/GameNave4/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/izabely-furtado/GameNave4/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h2>
<a id="trabalho-da-disciplina-poo-2" class="anchor" href="#trabalho-da-disciplina-poo-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>TRABALHO DA DISCIPLINA POO 2</strong>
</h2>

<p><strong>Projeto: WaterCraft</strong></p>

<p><strong>1.    Registro de Alterações</strong></p>

<p><strong>Versão</strong> = 4</p>

<p><strong>Responsáveis</strong> = Izabely Corrêa e Gislaine Almeida</p>

<p><strong>Data</strong> = 26/01/2015</p>

<p><strong>Alterações</strong> = </p>

<ul>
<li>Modificação dos Diagramas estruturais,</li>
<li>Demonstração mais detalhada da parte estrutural</li>
<li>Divisões de padrões em criacionais, estruturais e comportamentais</li>
<li>Diagrama e Explicação do Padrão Facade,</li>
<li>Explicação da implementação do Mediador</li>
<li>Explicação das mudanças, </li>
<li>Descrição da Utilização DAO</li>
<li>Foi modificada um pouco a jogabilidade</li>
</ul>

<h2>
<a id="2-introdução" class="anchor" href="#2-introdu%C3%A7%C3%A3o" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>2. Introdução</strong>
</h2>

<p>Este documento apresenta um relatório de projeto e engenharia do sistema de um jogo de naves. Este documento está organizado da seguinte forma: a seção 3 apresenta a composição estrutural do jogo demonstrando o diagrama de classes e o de composição de estruturas e descreve a utilização MVC, a seção 4 introduz os padrões que são explicados nas sessões logo a seguir, a seção 5 apresenta os padrões criacionais como o padrão Fábrica e o Builder utilizado, seus respectivos  diagramas, motivações e explicações, a seção 6 apresenta os padrão Peso Mosca e Facada utilizados, seus respectivos  diagramas, motivações e explicações, a seção 7 apresenta o padrão mediador e como está inserido no código, a seção 8 está a explicação do banco de dados, a seção 9 demonstra a diferença evidenciada com a refatoração do código, a seção 10 explica em que pontos foi testado o programa, a seção 11 indica a aplicação do Reflection, a seção 12 descreve um passo a passo de como deve rodar o programa.</p>

<h2>
<a id="3-composição-estrutural" class="anchor" href="#3-composi%C3%A7%C3%A3o-estrutural" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>3. Composição Estrutural</strong>
</h2>

<p>A arquitetura de software do sistema é uma combinação de camadas e partições. O subsistema Jogo Nave está organizado em camadas que são: Camada de Visão (Camada de interface com o usuario), a Camada de Dominio do Problema e a Camada de Gestão de Tarefas (Camada de Lógica de Negócio), a Camada de Controle e Camada de Gestão de Dados. A seguir o projeto desses componentes é apresentado.</p>

<p><strong>Diagrama de Composição de Estruturas</strong></p>

<p><img src="https://github.com/izabely-furtado/GameNave4/blob/master/diagramas/composi%C3%A7%C3%A3oEstrutural.png?raw=true" alt=""></p>

<p>Esse diagrama destina-se a descrição dos relacionamentos entre os elementos. Utilizado para descrever a colaboração interna de classes, interfaces ou componentes para especificar uma funcionalidade.</p>

<p>Essa colaboração interna começa a se basear no modelo MVC, que se trata de um padrão de arquitetura de software que separa a representação da informação da interação do usuário com ele. Utilizando-se das ideias centrais por trás do MVC, que são a reusabilidade de código e separação de conceitos.</p>

<h2>
<a id="padrão-arquitetural" class="anchor" href="#padr%C3%A3o-arquitetural" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>Padrão Arquitetural</strong>
</h2>

<p>O padrão arquitetural escolhido acaba separando mais que simplesmente em modelo visão e persistência, tendo assim, além disso, um controlador para cada camada em questão. Assim seguem as justificativas para tal escolha para cada camada.</p>

<p>O modelo consiste nos dados da aplicação, regras de negócios, lógica e funções, que nesse caso estão na <strong>CamadaDomínioProblema</strong>, que possui as classes que foram indicadas no diagrama de classes.</p>

<p>Uma visão pode ser qualquer saída de representação dos dados, que estão na <strong>CamadaGestaoDados</strong>, como as músicas tocadas no jogo e as imagens que demonstram as naves a as munições, por exemplo.  Assim como podem ser representação de dados que pode se haver uma interação, como botões e janelas, que estão na <strong>CamadaInteraçãoHumana</strong>.</p>

<p>O controlador faz a mediação da entrada, convertendo-a em comandos para o modelo ou visão, estão nesse caso na CamadaControleInterface.</p>

<p>Assim, a partir disse a camada de aplicação da nave, chama em uma linha a função da <strong>CamadaControleInterface</strong>  a função que chama o menu inicial.</p>

<p><strong>Visão</strong></p>

<p><img src="https://github.com/izabely-furtado/GameNave4/blob/master/diagramas/MVC-Vis%C3%A3o.png?raw=true" alt=""></p>

<p><strong>Modelo</strong></p>

<p><img src="https://github.com/izabely-furtado/GameNave4/blob/master/diagramas/MVC-Neg%C3%B3cio.png?raw=true" alt=""></p>

<p><strong>Persistência</strong></p>

<p><img src="https://github.com/izabely-furtado/GameNave4/blob/master/diagramas/MVC-Persistencia.png?raw=true" alt=""></p>

<h3>
<a id="subsistema" class="anchor" href="#subsistema" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>Subsistema</strong>
</h3>

<p><strong>Camada de Lógica de Negócio</strong></p>

<p>Para organizar a camada de lógica de negócio deste subsistema, foi escolhido o padrão Camada de Serviço. Sendo assim, essa camada é dividida em dois componentes: Componente de Domínio do Problema (cdp) e Componente de Gerência de Tarefas (cgt). Esse padrão utiliza um componente para tratar a lógica de aplicação (o cgt), o qual recebe as requisições da interface, e um componente para tratar os conceitos do domínio do problema, advindos do modelo conceitual estrutural elaborado na fase de análise (o cdp). A seguir, o projeto desses dois componentes é apresentado.</p>

<p><strong>Componente de Domínio do Problema (CDP)</strong></p>

<p>A figura a seguir apresenta o diagrama de classes do CDP do subsistema do jogo</p>

<p><img src="https://github.com/izabely-furtado/GameNave4/blob/master/diagramas/MVC%20-%20L%C3%B3gica%20-%20CDP.png?raw=true" alt=""></p>

<p><strong>Componente de Gerência de Tarefas (CGT)</strong></p>

<p>O projeto da aplicação é baseado principalmente nos casos de uso e seus respectivos eventos.  O tópico 10. irá descrever os casos de uso e seus respectivos eventos, descritos de forma a considerar a análise feita do sistema, assim, desconsiderando questões tecnológicas que podem vir a ser relacionadas. </p>

<h2>
<a id="4-padrões-de-projeto" class="anchor" href="#4-padr%C3%B5es-de-projeto" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>4. Padrões de Projeto</strong>
</h2>

<p>Os padrões de projetos usados no projeto da Lógica de Negócio são listados a seguir, bem como com suas respectivas justificativas.</p>

<p>A explicação é dividida por 3 tipos de padrões de projetos que foram aplicados, sendo estes:</p>

<ul>
<li>Criacional</li>
<li>Estrutural</li>
<li>Comportamental</li>
</ul>

<h2>
<a id="5-----padrões-criacionais" class="anchor" href="#5-----padr%C3%B5es-criacionais" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>5.     Padrões Criacionais</strong>
</h2>

<h3>
<a id="51--padrão-fábrica" class="anchor" href="#51--padr%C3%A3o-f%C3%A1brica" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>5.1.  Padrão Fábrica</strong>
</h3>

<p>Aplicada a Objetos nas Fases do Jogo: Naves e Itens</p>

<p><img src="https://github.com/izabely-furtado/GameNave2/blob/master/diagramas/PadraoFabrica.png?raw=true" alt=""></p>

<p><strong>5.1.1.    Motivo da Utilização</strong></p>

<p>O padrão em questão foi utilizado para fabricação de objetos que estarão em cada fase, sendo esses itens e/ou naves.</p>

<p>O Factory Method foi utilizado para esse projeto, pois nessas condições o padrão nos oferece um meio de desligar a implementação de um produto final em si. Por exemplo, caso quisesse desenvolver um novo inimigo, a criação deste estaria facilitada e em nível de chamada, pode-se chamar qualquer nave inimiga, como uma nave ou simplesmente um objeto. </p>

<p>Além disso, o padrão fábrica, faz com que não haja repetição de código, dado que caso queira fabricar um novo item, poderia já abstrair este como um objeto e somente implementar as modificações ocasionadas no jogo. Mas isso tudo é feito de forma mais intuitiva, como uma espécie de montagem facilitadora, uma casca que define a criação de elementos presentes em cada classe. Assim, há um local único para ser modificado, assim, um local único para fazer manutenção, dando um código flexível e extensível no futuro.</p>

<p>Para completar, caso o uma nave específica ou um item precise ser desligado ou deletado, a alteração não irá afetar demais classes, principalmente não irá afetar seu “criador”, pois eles não estarão fortemente ligados. Facilitando, assim, a manutenção do código, pois encapsula esse comportamento de instanciação.</p>

<p><strong>5.1.2.   Explicação do Diagrama</strong></p>

<p>No diagrama de classe acima temos a classe <strong>FabricaAtributoAcao</strong> definida como interface (já que Python não possui interface ela é apenas uma classe abstrata com funções abstratas) que define os métodos que deverão ser implementados por sua subclasse, a classe abstrata <strong>FabricaObjeto</strong>.</p>

<p>Ambas classes, tanto FabricaItem, quanto FabricaNave, que estendem a classe FabricaObjeto serão objetos na tela que possuem o mesmo comportamento de, ou seja, se movem e possuem uma figura que os representa. Estendendo de FabricaObjeto, possuem os atributos e podem utilizar e/ou sobrescrever os métodos existentes no super.</p>

<p>No diagrama de classes temos a classe <strong>FabricaObjeto</strong> como abstrata que define atributos que cabem a qualquer nave e objeto no jogo, além dos métodos que definem comportamentos comuns entre as naves e itens e que deverão ser sobrescritos por cada subclasse, que são:</p>

<ul>
<li>move()</li>
<li>criaVelocidade() </li>
</ul>

<p>Isso deve ser feito, pois cada nave possui seu próprio movimento, velocidade e, já que é uma nave também, sua própria resistência, no caso de um item, este deve possuir suas próprias modificações.</p>

<p><strong>5.1.2.1.  Fabrica Naves</strong></p>

<p><strong>5.1.2.1.1.    Inimigas</strong></p>

<p>Todas as naves inimigas devem conter o dado referente sobre a pontuação que o jogador arrecada por derrota-la, sendo que a explosão ficou igual a todas as naves por conveniência, no entanto, só algumas naves inimigas atiram.</p>

<p>Sendo assim, temos a classe <strong>FabricaNaveInimiga</strong> como abstrata estende <strong>FabricaNave</strong> e define atributos que cabem a qualquer nave inimiga, além disso, as classes que a estende, sobrescrevem as funções necessárias para toda nave, já mencionadas.</p>

<p>Alguns naves inimigas, além de implementarem as funções mencionadas, implementam atributos e métodos que possibilitam atirar.</p>

<p><strong>5.1.2.1.2.    Jogador</strong></p>

<p>A Nave do Jogador é análoga a qualquer nave, só que esta deve permitir que o jogador possa atirar em seus inimigos. </p>

<p><strong>5.1.2.2.  Fabrica Itens</strong></p>

<p>Cada item faz modificações na nave ou no status do jogador e, como tal, possui seu preço, caso queira ser trocada por uma pontuação e a probabilidade de aparecimento durante uma fase. Além de possuir os atributos e métodos que estão no super estendido, <strong>FabricaObjeto</strong>.</p>

<h3>
<a id="52--padrão-builder" class="anchor" href="#52--padr%C3%A3o-builder" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>5.2.  Padrão Builder</strong>
</h3>

<p>Aplicada a Fabrica de Naves</p>

<p><img src="https://github.com/izabely-furtado/GameNave3/blob/gh-pages/diagramas/PadraoBuild.png?raw=true" alt=""></p>

<p><strong>5.2.1.    Motivo da Utilização</strong></p>

<p>A motivação foi separar a construção de um objeto complexo de sua representação de modo que o mesmo processo de construção possa criar diferentes representações.</p>

<p>Nesse caso deu à separação da fabricação de uma nave, do dano causado a mesma, do som que esta emite e da imagem referente a ela e sua explosão. Seguindo em si, a mesma ideia dos padrões Factory Method e Abstract Factory. No entanto, permitindo separar os passos da construção da nave em pequenos métodos que são:</p>

<ul>
<li>BuildDano()</li>
<li>BuildImagemNave()</li>
<li>BuildImagemExplosao()</li>
<li>BuildSom()</li>
</ul>

<p>No padrão Builder temos também uma interface comum para todos os objetos que constroem outros objetos. Essa interface Builder define todos os passos necessários para construir  cada tipo de nave, sendo essa a de um jogador ou inimiga.</p>

<p><strong>5.2..2.   Explicação do Diagrama</strong></p>

<p><strong>5.2.2.1.  NaveProduct</strong></p>

<p>Nada mais é do que uma estrutura de dados que armazena as informações de uma nave. A nossa classe Builder vai possui um método para construir cada um dos dados do produto em questão.</p>

<p><strong>5.2.2.2.  NaveBuilder</strong></p>

<p>Nesta classe temos a nave que será construída, os passos para sua construção e um método que devolve a nave construída. </p>

<p>Está classe em questão é abstrata os métodos em si serão implementados por cada classe abstrata que o estender, não existindo assim um “algoritmo” bem definido, o algoritmo será definido em outro lugar nos filhos.  Sendo assim, em cada uma das classes que o estender esses métodos implementar estarão “personalizando” a nave.</p>

<p><strong>5.2.2.3.  NaveJogoDirector</strong></p>

<p>A classe chamada de <strong>Director</strong>, utiliza a estrutura do <strong>Builder</strong> para definir o algoritmo de construção do Produto.</p>

<p>Sendo que, dado um Builder, a classe vai executar os métodos de construção, definindo assim o algoritmo de construção de naves, e depois devolve nave. O código cliente vai lidar apenas com o Director, toda a estrutura e algoritmos utilizados para construir a nave fica por debaixo dos panos.</p>

<h2>
<a id="6-----padrões-estruturais" class="anchor" href="#6-----padr%C3%B5es-estruturais" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>6.     Padrões Estruturais</strong>
</h2>

<h3>
<a id="61--padrão-peso-mosca" class="anchor" href="#61--padr%C3%A3o-peso-mosca" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>6.1.  Padrão Peso-Mosca</strong>
</h3>

<p>Diagrama que representa a implementação do padrão peso-mostra aplicada a criação de novas naves inimigas</p>

<p><img src="https://github.com/izabely-furtado/GameNave3/blob/gh-pages/diagramas/PadraoFlyweight.png?raw=true" alt=""></p>

<p><strong>6.1.1.    Motivo da Utilização</strong></p>

<blockquote>
<p>"Esse padrão como usa compartilhamento para suportar eficientemente grandes quantidades de objetos de granularidade fina." - [1] GAMMA, Erich et al. Padrões de Projeto: Soluções reutilizáveis de software orientado a objetos.</p>
</blockquote>

<p>Esse padrão foi utilizado para reduzir o espaço de memória e processamento exigido para a construção de cada nova nave inserida no jogo. A utilização foi dado devido a que várias naves semelhantes são inseridas aleatoriamente no jogo.</p>

<p>Pela intenção percebemos que o padrão Flyweight cria uma estrutura de compartilhamento de objetos pequenos. Para o exemplo citado, o padrão será utilizado no compartilhamento de imagens entre as entidades, além de alguns atributos não mutáveis.</p>

<p><strong>6.1.2.    Exemplos de Código</strong></p>

<p>` 
class NaveFlyweightFactory (object):</p>

<pre><code> def __init__(self):

     self._standardBoss = [0, None]
     self._standardFuga = [0, None]
     self._standardGrupo = [0, None]
     self._standardJogador = [0, None]
     self._standardPeao = [0, None]
     self._standardPerdida = [0, None]
     self._standardPersegue = [0, None]
</code></pre>

<p>`</p>

<p>O <strong><em>init</em></strong> é feito de modo q inicializar a quantidades de naves como 0 e as naves como ainda não existentes, com isso o modo caso ainda não tenha sido setados os valores as naves não ocupam muito espaço e caso contrário, se for a primeira vez a nave é criada normalmente, mas das próximas vezes só é mudada a quantidade, ela não é criada do zero. Assim como mostrado no <strong>get_Standard_Boss</strong> abaixo.</p>

<p>`
     def get_Standard_Boss(self, quantNave):</p>

<pre><code>     e = self._standardBoss
     if e[1] == None:
         e[1] = NaveBossBuilder.__init__(NaveBossBuilder)
         self._standardBoss[0] = quantNave
         self._standardBoss[1] = e[1]

     return e 
</code></pre>

<p>`</p>

<h3>
<a id="62--padrão-facada" class="anchor" href="#62--padr%C3%A3o-facada" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>6.2.  Padrão Facada</strong>
</h3>

<p>Diagrama que representa a implementação do padrão facada aplicada a criação de novas naves de personagens. Esse padrão faz a relação e utiliza dos métodos criados em <strong>NaveJogoDirector</strong> e é usado pelo <strong>Controlador</strong> da camada de controle de interface.</p>

<p><img src="https://github.com/izabely-furtado/GameNave4/blob/master/diagramas/Padr%C3%A3oFacade.png?raw=true" alt=""></p>

<p><strong>6.2.1.    Motivo da Utilização</strong></p>

<p>Oculta toda a complexidade de uma ou mais classes através de uma fachada. A intenção desse Padrão de Projeto é simplificar uma interface. Buscando do "diretor" do builder somente as informações que são usadas pelo controlador, de forma que sejam chamadas de forma mais intuitiva e como uma forma de organização e abstração.</p>

<p>O principal benefício visto foi a organização do acesso aos dados, a abstração feita a partir do momento que esse método foi implementado ajudou bastante, ainda mais dado que o código é compartilhado pelo grupo.</p>

<h2>
<a id="7-padrões-comportamentais" class="anchor" href="#7-padr%C3%B5es-comportamentais" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>7. Padrões Comportamentais</strong>
</h2>

<h3>
<a id="71--padrão-mediador" class="anchor" href="#71--padr%C3%A3o-mediador" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>7.1.  Padrão Mediador</strong>
</h3>

<p>Por todo o código, na aplicação de cada padrão e a comunicação entre os mesmos e os controladores foi utilizado o padrão mediador, sendo este uma interface que define as mensagens ou comunicações em si entre as classes e as camadas, como um leva e trás de informações e pacotes.</p>

<h2>
<a id="8-banco-de-dados---activerecord" class="anchor" href="#8-banco-de-dados---activerecord" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>8. Banco de Dados - ActiveRecord</strong>
</h2>

<p>Diagrama que representa a implementação para o uso e criação do banco de dados</p>

<p><strong>Motivo da Utilização</strong></p>

<p>&lt;&lt;&lt;&gt;&gt;&gt;</p>

<p><strong>Explicação do Diagrama</strong></p>

<p>&lt;&lt;&lt;&gt;&gt;&gt;</p>

<h2>
<a id="9-refatoração-do-código---avaliação-sonar" class="anchor" href="#9-refatora%C3%A7%C3%A3o-do-c%C3%B3digo---avalia%C3%A7%C3%A3o-sonar" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>9. Refatoração do Código - Avaliação SONAR</strong>
</h2>

<p><strong>Resultados do Sonar</strong></p>

<h3>
<a id="1-na-primeira-versão" class="anchor" href="#1-na-primeira-vers%C3%A3o" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>1. Na primeira versão</strong>
</h3>

<p><img src="https://github.com/izabely-furtado/GameNave2/blob/master/diagramas/sonar1.png?raw=true" alt=""></p>

<h3>
<a id="2-na-segunda-versão" class="anchor" href="#2-na-segunda-vers%C3%A3o" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>2. Na segunda versão</strong>
</h3>

<p><img src="https://github.com/izabely-furtado/GameNave2/blob/master/diagramas/sonar2.png?raw=true" alt=""></p>

<p>Os padrões de projeto, como já mencionados acima, ajudaram para que o código fosse melhor avaliado pelo sonar.</p>

<h3>
<a id="3-na-segunda-versão" class="anchor" href="#3-na-segunda-vers%C3%A3o" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>3. Na segunda versão</strong>
</h3>

<p><img src="https://github.com/izabely-furtado/GameNave3/blob/gh-pages/diagramas/sonar3.png?raw=true" alt=""></p>

<p>Dado o uso do método fábrica, por exemplo, o nível de duplicação do código está em 0.0%. </p>

<p>E, isso ocorreu mesmo com a criação de diversas novas classes referentes a objetos na tela em geral, tanto itens, quanto naves foram “fabricadas” de modo a fazer com que não houvesse essa duplicação. Dado a percepção do que havia em comum entre as classes.</p>

<p>O padrão builder, assim como o fábrica funcionou dá mesma forma. Só que evidenciando fatores mutáveis nas naves.</p>

<p>Além disso, funções escritas com poucas linhas de forma objetiva e intuitiva, além de ajudar na troca de código dentre o grupo, melhorou a nota referente a funções do sonar.
Mas aplicar o padrão fez com que as linhas de código aumentassem e muito de início, no entanto, por exemplo, os padrões fábrica e builder facilitam caso queira se inserir uma nova classe com comportamento diferenciado. Essa facilidade é adquirida de duas formas:</p>

<p>Considerando que já há um molde para a criação do novo objeto, não vai haver a “criação da roda” já que muitos quesitos simplesmente serão aproveitados.</p>

<p>O aproveitamento do código já existente evita a duplicação</p>

<p>Já nessa terceira versão houve uma motivação para serem feitas algumas modificações necessárias, mas primordialmente não mudou muito na nota dada pelo sonar, dado que o padrão implementado, em si, modifica mais em tempo de execução do na formatação do código em si.</p>

<p>Na real aumentaram o número de classes, pois passou ser mais orientado a interface e por conta dos diversos padrões implementados.</p>

<h2>
<a id="10--testes-unitários" class="anchor" href="#10--testes-unit%C3%A1rios" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>10.  Testes Unitários</h2>

<p>Os testes unitários foram aplicados nos seguinte locais:</p>

<ul>
<li>nas funções de negócio relacionadas ao <strong>Controle</strong>, verificando se as naves obedecem aos parâmetros da tela</li>
<li>nas funções de contrução e criação relacionadas a <strong>FabricaNave</strong> e seus descendentes, primordialmente relacionado aos movimentos das naves</li>
<li>nas funções do <strong>NaveBuilder</strong> relacionadas e inserção de dano nas naves</li>
<li>nas habilidades relacionadas primordialmente a <strong>Munição</strong>
</li>
<li>no <strong>Jogador</strong> relacionadas as funções que modificam os atributos do mesmo</li>
</ul>

<h2>
<a id="11----reflection" class="anchor" href="#11----reflection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>11.    Reflection</strong>
</h2>

<p>Visando fazer com que o programa tenha a capacidade de um programa de observar ou até mesmo modificar a sua estrutura ou comportamento de uma nave em tempo de execução foi usado o <strong>Reflection</strong> relacionando com a construção e um <strong>BuildGeral</strong> para a criação de naves da seguinte forma:</p>

<p>`
class BuildGeral(object):</p>

<pre><code>@staticmethod
def criar(name):
    path = 'util.Build.Nave'+ name + 'Builder'
    #'util.Build.NavesGrupoBuilder'
    components = name.split('.')
    mod = __import__(components[0])

    for comp in components[1:]:
        mod = getattr(mod, comp)
</code></pre>

<p>`</p>

<h2>
<a id="12----instalação" class="anchor" href="#12----instala%C3%A7%C3%A3o" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>12.    Instalação</strong>
</h2>

<p>Futuramente o jogo pretende gerar um executável para facilitar a inicialização do jogo para ser usado, mas enquanto essas melhorias não são implementadas algumas configurações devem ser realizadas. </p>

<p>Para que o jogo nave rode em um computador é necessário fazer a instalação do python versão 3.4, foi utilizado e a biblioteca pygame compatível com a versão do python utilizada. Utilizando uma ide que possa ser configurado o Python para interpretar, o programa pode ser rodado e jogado, ainda não como gostaríamos devido a vários contratempo tecnológicos e de aprendizado, mas em uma versão bem básica. </p>

<p><strong>Observação:</strong> Ao tentar rodar no Windows pode ser que não seja possível executar, pois a biblioteca de jogos para esse sistema só abrange até o python 3.2 e o programa utiliza como base outra versão. Por algum motivo que ainda não descobrimos, as imagens não estão sendo possíveis de ser carregadas sem que se passe o caminho das mesmas.</p>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/izabely-furtado">izabely-furtado</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
